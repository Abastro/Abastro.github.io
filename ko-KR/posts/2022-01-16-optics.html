<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Blog Abs - Optics, 자료구조를 가로지르는 방법</title>
        <link rel="stylesheet" href="../../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../../ko-KR">Blog Abs</a>
            </div>
            <nav>
                <a href="../../ko-KR">Home</a>
                <a href="../../ko-KR/about.html">About</a>
                <a href="../../ko-KR/contact.html">Contact</a>
                <a href="../../ko-KR/archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Optics, 자료구조를 가로지르는 방법</h1>
            <article>
    <section class="header">
        Posted on January 16, 2022
        
    </section>
    <section>
        <blockquote>
<p><em>함수형에 별로 관심이 없으신 줄 알았는데, 의외로 관심있으신 분들이 꽤 계셨습니다. 그분들을 위해 Optics가 무엇인지 설명을 해 보고자 합니다.</em></p>
</blockquote>
<p>우리는 자료구조를 가로지르며 연산을 하는 경우가 많은데요. 간단하게는 for문으로부터 시작해서 트리 순회(tree traversal)까지 다양한 경우가 있죠.</p>
<p>여기선 함수형이 이 문제들을 어떻게 접근하는지 알아보려 합니다.</p>
<hr />
<h1 id="개요">개요</h1>
<p>우리가 자료구조를 가로지르며 작업을 할 때에는, 보통 일부 원소를 가져와서 각각에 대해 작업을 진행합니다.</p>
<p>이렇게 접근하는 작업은 종류에 따라 다양하지만, 대부분의 경우 연산 1~2개로 구현이 가능합니다.</p>
<p>다음과 같은 경우를 생각해 봅시다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Foo</span><span class="op">(</span>B b<span class="op">,</span> C c<span class="op">,</span> D d<span class="op">)</span></span></code></pre></div>
<p>여기서, get과 set만 있으면 <code>B b</code> 에 접근하여 어떤 작업도 구현이 가능할 겁니다.</p>
<p>이 get과 set을 하나로 모아서, 필드로서의 개념을 encapsulate하는 접근자를 만들 수 있습니다. 함수형으로는 다음과 같이 됩니다:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="kw">class</span> <span class="fu">LensFooB</span><span class="op">(</span>get<span class="op">:</span> Foo <span class="op">=&gt;</span> B<span class="op">,</span> set<span class="op">:</span> B <span class="op">=&gt;</span> Foo <span class="op">=&gt;</span> Foo<span class="op">)</span></span></code></pre></div>
<p>이렇게 다루는 방식을 Optics라 합니다.</p>
<p>물론 이뿐 아니라 <code>B b1, B b2, C c, D d</code> 같이 B가 여럿 있는 경우도 다른 Optics를 사용하여 가로지를 수 있는데, 이것은 나중에 설명하도록 하겠습니다.</p>
<p>Optics를 이용하면, 명시적으로 필요한 접근자만 밖으로 드러나게 하거나 새로운 접근자를 만들어 마치 field가 있는 것처럼 꾸미는 것이 가능합니다.</p>
<p>한편, Optics는 기존의 데이터를 변하게 하지 않고, 새로운 데이터를 만드는 방식을 채택합니다.</p>
<p>예를 들어 <code>S s</code>를 변경하여 또 다른 <code>S s2 = lensB.set (b) (s)</code> 가 나오는 식이죠.</p>
<p>장단점이 있습니다만 여기서 기술하지는 않겠습니다.</p>
<p>(참고로, 전체를 deep-copy하지는 않고 B로 가는 reference만 바꾼 새로운 S객체를 반환하게 됩니다)</p>
<hr />
<h1 id="표현">표현</h1>
<p>일반적으로, Optics는 2가지로 표현할 수 있습니다.</p>
<h2 id="일반적인-표현법">일반적인 표현법</h2>
<p>선술했던 get/set을 이용하는 방법이 이에 해당합니다. 다음과 같이 표현할 수 있죠.</p>
<p><code>case class Lens[S, A](get : S =&gt; A, set: A =&gt; S =&gt; S)</code></p>
<p>이렇게 직관적으로 간단한 표현법을 사용할 수 있습니다.</p>
<p>어떤 연산이 있는지 등의 구체적인 부분은 분류에서 설명하겠습니다.</p>
<h2 id="van-laarhoven-표현법">Van Laarhoven 표현법</h2>
<p>하지만, 위 방법으로는 합성이 어려워지고, 앞으로 보게 될 유사성도 포착하기 어렵습니다.</p>
<p>예를 들어, <code>S</code>에 <code>A a</code>라는 원소가 있고, <code>A</code>에 <code>B b</code>라는 원소가 있는 경우를 생각해 봅시다.</p>
<p>그렇다면, B를 set해주기 위해서는 다음과 같이 해줘야 합니다:</p>
<p><code>S s2 =</code></p>
<p>이렇게 합성이 어려운 경우에는 문제가 있겠죠. 이를 보완하기 위해 다른 표현 방법이 있습니다.</p>
<p>일단, 각각의 원소에 작업을 어떻게 하는지를 추상화합시다.</p>
<p>어떤 타입 <code>A</code>를 가져와, 작업을 하고, 다른 <code>A</code>로 바꾸면 되겠죠? 이것은 각각의 원소에 대해 반복하면 됩니다.</p>
<p>어떻게 할까요?</p>
<p><code>type Optics[P, S, A] = P[A, A] =&gt; P[S, S]</code></p>
<h2 id="다형성">다형성</h2>
<p>가끔 다형성을 지닌 자료구조에 원소의 타입을 변경하며 가로질러야 할 때도 있습니다.</p>
<p>간단히 List타입 생성자를 생각해보죠.</p>
<hr />
<h1 id="분류">분류</h1>
<p>이 원소가 하나의 자료구조 안에 몇 개가 있는지에 따라 분류해 볼 수 있겠죠.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Total</th>
<th style="text-align: center;">Partial</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>1</em></td>
<td style="text-align: center;">Iso</td>
<td style="text-align: center;">Lens</td>
</tr>
<tr class="even">
<td style="text-align: center;"><em>0-1</em></td>
<td style="text-align: center;">Prism</td>
<td style="text-align: center;">Affine Traversal</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><em>Many</em></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Traversal</td>
</tr>
</tbody>
</table>
<p>이렇게 내부 원소가 유일하냐, “있거나 없거나” 인가, 여럿이냐에 따라 나눌 수 있고,</p>
<p>내부 원소가 전체인가 여부에 따라 나눌 수도 있습니다.</p>
<p>그리고 자료구조의 입장으로서 이 접근자들은 다음과 같은 상속 관계를 가집니다:</p>
<p>(상속 관계 넣기)</p>
<hr />
<p>그럼 이제 하나하나 알아보겠습니다.</p>
<h1 id="lens">Lens</h1>
<h2 id="표현-1">표현</h2>
<p>Lens의 경우, Var Laarhoven 표현이 상당히 간단하게 나옵니다.</p>
<h2 id="용법">용법</h2>
<p>First-class property처럼 사용할 수 있습니다.</p>
<p>한편, (Affine) Traversal로 간주하여 사용하기에도 유용합니다. 이 부분은 Traversal 단락에서 자세히 설명하겠습니다.</p>
<h1 id="iso">Iso</h1>
<p>Iso는 ’같다’는 뜻의 Isomorphism에서 유래했습니다.</p>
<p>이름에 걸맞게, Iso는 타입 A와 타입 B가 같다는 것을 표현하기 위해 쓰입니다.</p>
<h2 id="표현-2">표현</h2>
<p>Van Laarhoven 표현은 생각보다 복잡한데, 그리 쓸모는 없습니다.</p>
<h2 id="용법-1">용법</h2>
<p>단순히 함수 두개를 합친 것이기 때문에 사실 동등성을 명시하는 것 이외에 별로 쓸모가 없습니다.</p>
<p>따라서, Iso를 Lens나 Prism 등과 합성해서 쓰는 경우가 많습니다. Iso는 Lens와 Prism 둘 다 되거든요.</p>
<h1 id="affine-traversal">Affine Traversal</h1>
<h2 id="표현-3">표현</h2>
<h2 id="용법-2">용법</h2>
<h1 id="prism">Prism</h1>
<h2 id="표현-4">표현</h2>
<h2 id="용법-3">용법</h2>
<h1 id="traversal">Traversal</h1>
<h2 id="표현-5">표현</h2>
<h2 id="용법-4">용법</h2>
<p>To be continued…</p>
    </section>
</article>

        </main>

        <footer>
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
