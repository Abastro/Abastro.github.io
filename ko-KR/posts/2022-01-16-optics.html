<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta http-equiv="cache-control" content="max-age=0">
        <meta http-equiv="cache-control" content="no-cache">        
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Blog Abs - Optics, 자료구조를 가로지르는 방법</title>
        <link rel="stylesheet" href="../../assets/fontawesome/css/all.css" />
        <link rel="stylesheet" href="../../css/default.css" />
        <link rel="stylesheet" href="../../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../../ko-KR">Blog Abs</a>
            </div>
            <nav>
                <a href="../../ko-KR"><i class="fa-solid fa-house"></i></a>
                <a href="../../ko-KR/about.html"><i class="fa-solid fa-circle-question"></i></a>
                <a href="../../ko-KR/contact.html"><i class="fa-solid fa-address-card"></i></a>
                <a href="../../ko-KR/archive.html"><i class="fa-solid fa-box-open"></i></a>
            </nav>
        </header>

        <main role="main">
            <h1>Optics, 자료구조를 가로지르는 방법</h1>
            <article>
    <section class="header">
        Posted on January 16, 2022
        
    </section>
    <section>
        <blockquote>
<p><em>함수형에 별로 관심이 없으신 줄 알았는데, 의외로 관심있으신 분들이 꽤 계셨습니다.
그분들을 위해 Optics가 무엇인지 설명을 해 보고자 합니다.</em></p>
</blockquote>
<blockquote>
<p><em>이 글은 함수형에 익숙한 분들을 위해 작성되었습니다.</em></p>
</blockquote>
<blockquote>
<p><em>설명을 위해 Scala를 사용하지만, 컴파일이 안 된 코드입니다.
직접 구현해 보시려면, Typeclass를 작성하는 방향으로 작업하시면 됩니다.</em></p>
</blockquote>
<blockquote>
<p><em>법칙은 설명하지 않습니다.</em></p>
</blockquote>
<p>우리는 자료구조를 가로지르며 연산을 하는 경우가 많은데요.
간단하게는 for문으로부터 시작해서 트리 순회(tree traversal)까지 다양한 경우가 있죠.</p>
<p>여기선 함수형이 이 문제들을 어떻게 접근하는지 알아보려 합니다.</p>
<hr />
<h1 id="개요">개요</h1>
<p>우리가 자료구조를 가로지르며 작업을 할 때에는, 보통 일부 원소를 가져와서 각각의 원소에 대해 작업을 진행합니다.</p>
<p>이렇게 접근하는 작업은 종류에 따라 다양하지만, 대부분의 경우 연산 1~2개로 커버가 됩니다.</p>
<p>예를 들어 다음 구조체를 봅시다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Foo</span><span class="op">(</span>B b<span class="op">,</span> C c<span class="op">,</span> D d<span class="op">)</span></span></code></pre></div>
<p>여기서 get과 set만 있으면 <code>B b</code> 에 접근하여 어떤 작업도 구현이 가능할 겁니다.</p>
<p>이 get과 set을 하나로 모아서, 필드로서의 개념을 encapsulate하는 접근자를 만들 수 있습니다.
함수형으로는 다음과 같이 됩니다:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">LensFooB</span><span class="op">(</span>get<span class="op">:</span> Foo <span class="op">=&gt;</span> B<span class="op">,</span> set<span class="op">:</span> B <span class="op">=&gt;</span> Foo <span class="op">=&gt;</span> Foo<span class="op">)</span></span></code></pre></div>
<p>get은 해당 필드를 가져오는 함수, set은 해당 필드를 변경한 값을 돌려주는 함수입니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lensFooB <span class="op">:</span> LensFooB <span class="op">=</span> <span class="op">???</span> <span class="co">// Omitted</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> foo <span class="op">=</span> <span class="fu">Foo</span> <span class="op">(</span>b<span class="op">,</span> c<span class="op">,</span> d<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  lensFooB<span class="op">.</span><span class="fu">get</span> <span class="op">(</span>foo<span class="op">)</span> <span class="op">==</span> b</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  lensFooB<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>b2<span class="op">)</span> <span class="op">(</span>foo<span class="op">)</span> <span class="op">==</span> <span class="fu">Foo</span> <span class="op">(</span>b2<span class="op">,</span> c<span class="op">,</span> d<span class="op">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  foo <span class="op">==</span> <span class="fu">Foo</span> <span class="op">(</span>b<span class="op">,</span> c<span class="op">,</span> d<span class="op">)</span> <span class="co">// No mutation</span></span></code></pre></div>
<p>특히, 함수형에서는 값에 변화를 주는 것을 싫어하므로,
Foo를 shallow-copy 방식으로 복사하여 해당 필드만 수정한 새로운 값을 돌려주게 됩니다.</p>
<p>이렇게 접근자를 따로 빼내어 <em>first-class</em>로서 다루는 방식을 Lens,
이를 일반화하여 순회 방식으로 연산하는 방식을 Optics라고 부릅니다.</p>
<p>Optics를 이용하면, 명시적으로 필요한 접근자만 밖으로 드러나게 하거나
새로운 접근자를 만들어 마치 field가 있는 것처럼 꾸미는 것이 가능합니다.</p>
<hr />
<h1 id="표현">표현</h1>
<p>일반적으로, Optics는 2가지로 표현할 수 있습니다.</p>
<h2 id="일반적인-표현법">일반적인 표현법</h2>
<p>선술했던 get/set을 이용하는 방법이 이에 해당합니다. 다음과 같이 표현할 수 있죠.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> LensS<span class="op">[</span>S<span class="op">,</span> A<span class="op">](</span>get <span class="op">:</span> S <span class="op">=&gt;</span> A<span class="op">,</span> set<span class="op">:</span> A <span class="op">=&gt;</span> S <span class="op">=&gt;</span> S<span class="op">)</span></span></code></pre></div>
<p>이렇게 직관적으로 간단한 표현법을 사용할 수 있습니다.
허나, 이 방식이 모든 Optics에 대해 적용되는 건 아닙니다.</p>
<h2 id="profunctor-표현법">Profunctor 표현법</h2>
<h3 id="동기">동기</h3>
<p>하지만, 위 방법으로는 합성이 어려워지고, 앞으로 보게 될 유사성도 포착하기 어렵습니다.</p>
<p>예를 들어, <code>S</code>에 <code>A a</code>라는 원소가 있고, <code>A</code>에 <code>B b</code>라는 원소가 있는 경우를 생각해 봅시다.</p>
<p>그렇다면, <code>B</code>를 <code>b2</code>로 설정해주기 위해서는 다음과 같이 해줘야 합니다:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> A a2 <span class="op">=</span> lensAB<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>b2<span class="op">)</span> <span class="op">(</span>lensSA<span class="op">.</span><span class="fu">get</span> <span class="op">(</span>s<span class="op">))</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> S s2 <span class="op">=</span> lensSA<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>a2<span class="op">)</span> <span class="op">(</span>s<span class="op">)</span></span></code></pre></div>
<p>여기서 3단계로 중복이 되면 더 복잡해집니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> B b2 <span class="op">=</span> lensBC<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>c2<span class="op">)</span> <span class="op">(</span>lensAB<span class="op">.</span><span class="fu">get</span> <span class="op">(</span>lensSA<span class="op">.</span><span class="fu">get</span> <span class="op">(</span>s<span class="op">)))</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> A a2 <span class="op">=</span> lensAB<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>b2<span class="op">)</span> <span class="op">(</span>lensSA<span class="op">.</span><span class="fu">get</span> <span class="op">(</span>s<span class="op">))</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> S s2 <span class="op">=</span> lensSA<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>a2<span class="op">)</span> <span class="op">(</span>s<span class="op">)</span></span></code></pre></div>
<p>복잡해서 읽기도 힘들고, 스케일이 커질수록 문제가 커지네요. 저도 쓰기 힘들었습니다;;;</p>
<p>바로 이 단점을 보완할 뿐 아니라, 일반적으로 더 많은 사용법을 포괄하는 표현법이 있습니다.</p>
<h3 id="작업하기---profunctor">작업하기 - Profunctor</h3>
<p>일단, 각각의 원소에 작업을 어떻게 하는지를 추상화해 봅시다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Foo</span><span class="op">(</span>Bar bar<span class="op">,</span> Baz baz<span class="op">)</span></span></code></pre></div>
<p>여기서 <code>Foo</code> 내부의 <code>Bar bar</code>에 작업을 하려면, 필드 <code>bar</code>에 적용할 작업이 필요합니다.
이 작업을 <code>taskBar</code>라고 불러봅시다.</p>
<p><code>taskBar</code>는 <code>bar</code> 필드를 다른 값으로 바꿔줄 수 있어야 하기 때문에,
새로운 값 <code>Bar bar2</code>을 돌려줄 수도 있어야 하겠죠.</p>
<p>그러면 <code>taskBar</code>의 타입은 다음과 같이 상상할 수 있습니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> taskBar <span class="op">:</span> Bar <span class="op">=&gt;</span> Bar</span></code></pre></div>
<p>하지만 이런 작업은 부가작용(side effect)을 표현하지 못할 뿐더러,
<code>get</code>을 구현하기에도 애매모호합니다.</p>
<p>그럼 <code>F</code>라는 펑터(Functor)를 이용해 부가작용을 할 수 있게 해봅시다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> taskBar <span class="op">:</span> Bar <span class="op">=&gt;</span> F<span class="op">[</span>Bar<span class="op">]</span></span></code></pre></div>
<p>사실 이 정도에서 끊어도 되지만, Prism을 설명하기 위해 한 단계 더 가보겠습니다.</p>
<p>단순 작업을 생각하면, 기존 <code>Bar</code>값이 필요하지 않은 경우도 있습니다.
특히 <code>Bar</code>객체의 값을 새로 만들어 내는 경우엔 위 방법이 통하지 않겠죠.</p>
<p>이 경우를 커버하기 위해서, 함수를 일반화한 개념인 <code>Profunctor</code>가 등장합니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> taskBar <span class="op">:</span> P<span class="op">[</span>Bar<span class="op">,</span> Bar<span class="op">]</span></span></code></pre></div>
<p>P가 다음과 같은 조건을 만족하는 경우, <code>Profunctor</code>라고 부릅니다:</p>
<p>P는 타입 2개를 받는 Type Constructor이어야 하고,
첫번째 인자엔 반-Functor로, 두번째 인자엔 Functor로 동작합니다(???)…</p>
<p>무슨 말인고 하니, 다음과 같이 input과 output에 함수를 이어줄 수 있다는 겁니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> inputFn <span class="op">:</span> Dog <span class="op">=&gt;</span> Bus    <span class="co">// Function</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> busToCar <span class="op">:</span> P<span class="op">[</span>Bus<span class="op">,</span> Car<span class="op">]</span>  <span class="co">// P</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> outputFn <span class="op">:</span> Car <span class="op">=&gt;</span> Cat   <span class="co">// Function</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> dogToCat <span class="op">:</span> P<span class="op">[</span>Dog<span class="op">,</span> Cat<span class="op">]</span> <span class="op">=</span> Profunctor<span class="op">[</span>P<span class="op">].</span><span class="fu">dimap</span> <span class="op">(</span>inputFn<span class="op">)</span> <span class="op">(</span>outputFn<span class="op">)</span> <span class="op">(</span>busToCar<span class="op">)</span></span></code></pre></div>
<p>함수 합성과 비슷하네요. 다만 P끼리는 잇지 못합니다.</p>
<p>다음과 같이 trait을 통해 P에 대한 제약조건으로 만들어 줄 수 있습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trait</span> Profunctor<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]]</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dimap<span class="op">[</span>S<span class="op">,</span> T<span class="op">,</span> A<span class="op">,</span> B<span class="op">]</span> <span class="op">(</span>inFn<span class="op">:</span> S <span class="op">=&gt;</span> A<span class="op">)</span> <span class="op">(</span>outFn<span class="op">:</span> B <span class="op">=&gt;</span> T<span class="op">)</span> <span class="op">:</span> P<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>S<span class="op">,</span> T<span class="op">]</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>이제 작업 <code>taskBar: P[Bar, Bar]</code>을 정의했으니, 이를 <code>P[Foo, Foo]</code>로 승격시켜줄 필요가 있겠죠?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> OpticS<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Bar<span class="op">]</span> <span class="op">=</span> P<span class="op">[</span>Bar<span class="op">,</span> Bar<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>Foo<span class="op">,</span> Foo<span class="op">]</span></span></code></pre></div>
<p>이렇게 부분에 한정된 작업을 전체로 승격시키는 함수를 Optic이라 합니다.</p>
<p>Optic은 함수이므로, 다음과 같이 <strong>손쉽게 합성이 가능합니다.</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> pFooBar<span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Bar<span class="op">]</span> <span class="co">// Bar is inside Foo</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> pBarBaz<span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Bar<span class="op">,</span> Baz<span class="op">]</span> <span class="co">// Baz is inside Bar</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> pFooBaz<span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Baz<span class="op">]</span> <span class="op">=</span> pFooBar compose pBarBaz</span></code></pre></div>
<h3 id="자료구조에-할-수-있는-작업">자료구조에 할 수 있는 작업</h3>
<p>자료구조 입장에서는, encapsulation을 위해 가능한 작업에 제약을 걸어줘야 하는 일이 생깁니다.</p>
<p>이를 위해 <code>Optics</code>의 경우에는 작업 <code>P</code>에 제약을 걸게 되죠.</p>
<p>예를 들어, <code>lensFooBar</code>는 다음과 같이 표현됩니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Strong has Profunctor as its superclass</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lensFooBar<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Bar<span class="op">]</span></span></code></pre></div>
<p>보시듯이 <code>Strong</code>이라는 제약조건이 들어가 있습니다. (이게 무엇인지는 후술할 예정입니다)</p>
<p>이렇게 <code>lensFooBar</code>처럼 제약조건을 포함한 개념을 Optics 접근자라 부릅니다.</p>
<p>어떤 제약조건이 붙는지에 따라서 분류도 가능한데, 다형성을 먼저 다루고 설명해 보겠습니다.</p>
<h2 id="다형성">다형성</h2>
<p>가끔 다형성을 지닌 자료구조에 원소의 타입을 변경하며 가로질러야 할 때도 있습니다.</p>
<p>간단히 List타입을 생각해 보죠.</p>
<p><code>Car =&gt; Bus</code>라는 함수를 적용해 바꿔주는 연산을 하면,
<code>List[Car]</code>은 <code>List[Bus]</code>가 되어야 합니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> listMap <span class="op">:</span> <span class="op">(</span>Car <span class="op">=&gt;</span> Bus<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span><span class="ex">List</span><span class="op">[</span>Car<span class="op">]</span> <span class="op">=&gt;</span> <span class="ex">List</span><span class="op">[</span>Bus<span class="op">])</span></span></code></pre></div>
<p>이 경우도 고려하도록 만들어 줄 수 있을까요? <code>Optics</code> 타입의 정의를 생각해 봅시다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Optics<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Bar<span class="op">]</span> <span class="op">=</span> P<span class="op">[</span>Bar<span class="op">,</span> Bar<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>Foo<span class="op">,</span> Foo<span class="op">]</span></span></code></pre></div>
<p><code>P</code>의 input과 output 타입이 같았었죠? 이걸 달리해 주면 어떻게 될까요?</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Optics<span class="op">[</span>P<span class="op">,</span> S1<span class="op">,</span> S2<span class="op">,</span> A1<span class="op">,</span> A2<span class="op">]</span> <span class="op">=</span> P<span class="op">[</span>A1<span class="op">,</span> A2<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>S1<span class="op">,</span> S2<span class="op">]</span></span></code></pre></div>
<p>그래서 다음과 같이 <code>List.map</code>의 타입을 Optics으로 표현할 수 있습니다!</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Arrow<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=</span> A <span class="op">=&gt;</span> B <span class="co">// Function</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ListMap = Arrow[Car, Bus] =&gt; Arrow[List[Car], List[Bus]]</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ListMap <span class="op">=</span> Optics<span class="op">[</span>Arrow<span class="op">,</span> <span class="ex">List</span><span class="op">[</span>Car<span class="op">],</span> <span class="ex">List</span><span class="op">[</span>Bus<span class="op">],</span> Car<span class="op">,</span> Bus<span class="op">]</span></span></code></pre></div>
<p>실제로 <code>List.map</code>도 Optic이 됩니다.</p>
<hr />
<h1 id="분류">분류</h1>
<p>이제 본격적으로 살펴보기 위해 각각의 케이스를 고려해 보겠습니다.</p>
<p>특히, 자료구조를 종류에 따라 분류하는 것이 중요합니다.</p>
<p>작업하고자 하는 원소가 하나의 자료구조 안에 몇 개가 있는지에 따라 분류해 볼 수 있겠죠.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Total</th>
<th style="text-align: center;">Partial</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>1</em></td>
<td style="text-align: center;">Iso</td>
<td style="text-align: center;">Lens</td>
</tr>
<tr class="even">
<td style="text-align: center;"><em>0-1</em></td>
<td style="text-align: center;">Prism</td>
<td style="text-align: center;">Affine Traversal</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><em>Many</em></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Traversal</td>
</tr>
</tbody>
</table>
<p>이렇게 내부 원소가 유일하냐, “있거나 없거나” 인가, 여럿이냐에 따라 나눌 수 있고,</p>
<p>내부 원소가 전체인가 여부에 따라 나눌 수도 있습니다.</p>
<p>한편, 이 접근자들은 다음과 같은 상속 관계를 가집니다:</p>
<p>(상속 관계 넣기)</p>
<p>예를 들어, Lens 접근자는 Affine Traversal로 쓸 수 있고,
Affine Traversal 접근자는 Traversal로써 쓸 수도 있습니다.</p>
<hr />
<p>그럼 이제 하나하나 알아보겠습니다.</p>
<h1 id="lens">Lens</h1>
<p>Lens는 렌즈를 이용해 구조체를 확대시켜 주는 느낌입니다.</p>
<p>일정한 필드 부분을 확대한 후, 이에 대한 작업을 진행합니다.</p>
<h2 id="표현-1">표현</h2>
<p>위에서 언급했듯이, 다음과 같은 일반적 표현이 가능합니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> LensS<span class="op">[</span>S<span class="op">,</span> A<span class="op">](</span>get <span class="op">:</span> S <span class="op">=&gt;</span> A<span class="op">,</span> set<span class="op">:</span> A <span class="op">=&gt;</span> S <span class="op">=&gt;</span> S<span class="op">)</span></span></code></pre></div>
<p>다형성을 고려하면, 이렇게 나옵니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> Lens<span class="op">[</span>S<span class="op">,</span> T<span class="op">,</span> A<span class="op">,</span> B<span class="op">](</span>get<span class="op">:</span> S <span class="op">=&gt;</span> A<span class="op">,</span> set<span class="op">:</span> B <span class="op">=&gt;</span> S <span class="op">=&gt;</span> T<span class="op">)</span></span></code></pre></div>
<p>이 경우, 원소의 타입이 A에서 B로 바뀌면서, 구조체의 타입이 S에서 T로 바뀌게 됩니다.</p>
<hr />
<p>한편 Profunctor 표현법에서, <code>Lens</code>예제를 들며 <code>Strong</code>이 나왔었습니다.</p>
<p><code>Strong</code>한 <code>Profunctor</code>는 다음 함수를 구현합니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trait</span> Strong<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Necessary</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> seconds<span class="op">[</span>A<span class="op">,</span> B<span class="op">,</span> S<span class="op">]:</span> P<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[(</span>S<span class="op">,</span> A<span class="op">),</span> <span class="op">(</span>S<span class="op">,</span> B<span class="op">)]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// firsts can be described in terms of seconds</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> firsts<span class="op">[</span>A<span class="op">,</span> B<span class="op">,</span> S<span class="op">]:</span> P<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[(</span>A<span class="op">,</span> S<span class="op">),</span> <span class="op">(</span>B<span class="op">,</span> S<span class="op">)]</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>A를 받고 B를 주는 연산이 있을 때, 추가로 S를 더 받고 더 주는 연산으로 승격시킬 수 있는 것입니다.</p>
<p>필드 이름을 제외한다면 record를 tuple로서 볼 수 있는 만큼, Lens는 record와 관계가 깊습니다.</p>
<p>위에서 보여드렸듯, Lens 자체의 타입은 이렇게 생겼습니다. (다형성을 고려하지 않은 경우)</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OpticS[P, Foo, Bar] = P[Bar, Bar] =&gt; P[Foo, Foo]</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lensFooBar<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Bar<span class="op">]</span></span></code></pre></div>
<h3 id="표현의-변환">표현의 변환</h3>
<p>Profunctor 형태로부터 일반적 형태는 쉽게 얻을 수 있습니다. 타입 치환을 하면 됩니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ToBar<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> Bar <span class="co">// Summarize M to Bar</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Arrow<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> N   <span class="co">// Simple modify</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lensFBTyp<span class="op">:</span> LensS<span class="op">[</span>Foo<span class="op">,</span> Bar<span class="op">]</span> <span class="op">=</span> <span class="fu">LensS</span><span class="op">(</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lensFooBar[ToBar] : (Bar =&gt; Bar) =&gt; (Foo =&gt; Bar)</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    lensFooBar<span class="op">[</span>ToBar<span class="op">]</span> <span class="op">(</span>identity<span class="op">),</span> <span class="co">// get</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lensFooBar[Arrow] : (Bar =&gt; Bar) =&gt; (Foo =&gt; Foo)</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>toSet<span class="op">:</span> A<span class="op">)</span> <span class="op">=&gt;</span> lensFooBar<span class="op">[</span>Arrow<span class="op">]</span> <span class="op">(</span>_ <span class="op">=&gt;</span> toSet<span class="op">)</span> <span class="co">// set</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">)</span></span></code></pre></div>
<p>(<code>ToBar</code>와 <code>Arrow</code>에 대해 <code>Strong</code> trait의 인스턴스를 만드는 부분은 생략합니다. 한번 예제삼아 만들어 보세요)</p>
<p>반대로 일반적 형태에서 Profunctor 형태를 얻기는 꽤 어렵습니다.
<code>seconds</code>를 사용해서 기존 구조체를 보존시켜줄 필요가 있습니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lensFBTyp<span class="op">:</span> LensS<span class="op">[</span>Foo<span class="op">,</span> Bar<span class="op">]</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lensFooBar<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Foo<span class="op">,</span> Bar<span class="op">]</span> <span class="op">=</span> barTrans <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// barTrans : P[Bar, Bar]</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> withOriginal<span class="op">:</span> P<span class="op">[(</span>Foo<span class="op">,</span> Bar<span class="op">),</span> <span class="op">(</span>Foo<span class="op">,</span> Bar<span class="op">)]</span> <span class="op">=</span> Strong<span class="op">[</span>P<span class="op">].</span>seconds<span class="op">[</span>Bar<span class="op">,</span> Bar<span class="op">,</span> Foo<span class="op">]</span> <span class="op">(</span>barTrans<span class="op">)</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Gets Bar from input Foo</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">getBarP</span> <span class="op">(</span>foo <span class="op">:</span> Foo<span class="op">):</span> <span class="op">(</span>Foo<span class="op">,</span> Bar<span class="op">)</span> <span class="op">=</span> <span class="op">(</span>foo<span class="op">,</span> lensFBTyp<span class="op">.</span><span class="fu">get</span> <span class="op">(</span>foo<span class="op">))</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sets modified Bar into output Foo</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">setBarP</span> <span class="op">(</span>pair<span class="op">:</span> <span class="op">(</span>Foo<span class="op">,</span> Bar<span class="op">)):</span> Foo <span class="op">=</span> lensFBTyp<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>pair<span class="op">.</span>_2<span class="op">)</span> <span class="op">(</span>pair<span class="op">.</span>_1<span class="op">)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of type P[Foo, Foo]</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    Profunctor<span class="op">[</span>P<span class="op">].</span><span class="fu">dimap</span> <span class="op">(</span>getBarP<span class="op">)</span> <span class="op">(</span>setBarP<span class="op">)</span> <span class="op">(</span>withOriginal<span class="op">)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<h2 id="용법">용법</h2>
<p>Lens는 first-class property처럼 사용할 수 있습니다. 특히, 쉬운 합성이 이점입니다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> busWheel<span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Bus<span class="op">,</span> Wheel<span class="op">]</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> wheelRubber<span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Wheel<span class="op">,</span> Rubber<span class="op">]</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> busRubber<span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Bus<span class="op">,</span> Rubber<span class="op">]</span> <span class="op">=</span> busWheel compose wheelRubber</span></code></pre></div>
<p>Lens에 <code>P</code>를 연산 타입으로 정해주면, <code>OpticS[P, A, B]</code>의 꼴로 나오게 되어 위와 같은 합성이 가능해집니다.
이를 이용하면 Nested Record에 작업하기가 용이해 집니다.</p>
<p>한편, Lens는 (Affine) Traversal로 간주하여 사용하기에도 유용합니다.
이 부분은 Traversal 단락에서 자세히 설명하겠습니다.</p>
<h1 id="iso">Iso</h1>
<p>Iso는 ’같다’는 뜻의 Isomorphism에서 유래했습니다.</p>
<p>이름에 걸맞게, Iso는 타입 A와 타입 B가 같다는 것을 표현하기 위해 쓰입니다.</p>
<h2 id="표현-2">표현</h2>
<p>기본적인 표현법은 다음과 같습니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> IsoS<span class="op">[</span>S<span class="op">,</span> A<span class="op">](</span>get <span class="op">:</span> S <span class="op">=&gt;</span> A<span class="op">,</span> review<span class="op">:</span> A <span class="op">=&gt;</span> S<span class="op">)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Polymorphic case</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> Iso<span class="op">[</span>S<span class="op">,</span> T<span class="op">,</span> A<span class="op">,</span> B<span class="op">](</span>get<span class="op">:</span> S <span class="op">=&gt;</span> A<span class="op">,</span> review<span class="op">:</span> B <span class="op">=&gt;</span> T<span class="op">)</span></span></code></pre></div>
<p><code>get</code>은 Lens의 <code>get</code>과 동일하고,
<code>review</code>는 정확히 반대 방향으로 가는 함수로, 동등함을 보여줍니다.
그리고, <code>review</code>를 “다시 구조체를 build한다” 고 볼 수도 있습니다.</p>
<p>Profunctor 표현법으로는, 다음과 같이 제약조건이 Profunctor밖에 없을 때 Iso가 됩니다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OpticS[P, Hell, Monday] = P[Monday, Monday] =&gt; P[Hell, Hell]</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> isoHellMon<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Hell<span class="op">,</span> Monday<span class="op">]</span></span></code></pre></div>
<h3 id="표현의-변환-1">표현의 변환</h3>
<p>Lens에 비해선 쉽습니다.</p>
<p>Profunctor 형태에서 일반 형태로:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ToMonday<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> Monday <span class="co">// Summarize M to Monday</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> FromMonday<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> Monday <span class="op">=&gt;</span> N   <span class="co">// Generate N from Moday</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> isoHMTyp<span class="op">:</span> IsoS<span class="op">[</span>Hell<span class="op">,</span> Monday<span class="op">]</span> <span class="op">=</span> <span class="fu">IsoS</span><span class="op">(</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// isoHellMon[ToMonday] : (Monday =&gt; Monday) =&gt; (Hell =&gt; Monday)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    isoHellMon<span class="op">[</span>ToMonday<span class="op">]</span> <span class="op">(</span>identity<span class="op">),</span> <span class="co">// get</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// isoBarBaz[FromMonday] : (Monday =&gt; Monday) =&gt; (Monday =&gt; Hell)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    isoHellMon<span class="op">[</span>FromMonday<span class="op">]</span> <span class="op">(</span>identity<span class="op">)</span> <span class="co">// review</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">)</span></span></code></pre></div>
<p>일반 형태에서 Profunctor 형태로:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> isoHMTyp<span class="op">:</span> IsoS<span class="op">[</span>Hell<span class="op">,</span> Monday<span class="op">]</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> isoHellMon<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Hell<span class="op">,</span> Monday<span class="op">]</span> <span class="op">=</span> monTrans <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// monTrans : P[Monday, Monday]</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// isoHMTyp.get : Hell =&gt; Monday  /  isoHMTyp.review : Monday =&gt; Hell</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    Profunctor<span class="op">[</span>P<span class="op">].</span><span class="fu">dimap</span> <span class="op">(</span>isoHMTyp<span class="op">.</span>get<span class="op">)</span> <span class="op">(</span>isoHMTyp<span class="op">.</span>review<span class="op">)</span> <span class="op">(</span>monTrans<span class="op">)</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<h2 id="용법-1">용법</h2>
<p>단순히 함수 두개를 합친 것이기 때문에, 사실 동등성을 명시하는 것 이외에는 쓸모가 없습니다.</p>
<p>따라서, Iso를 Lens나 Prism 등과 합성해서 쓰는 경우가 많습니다.</p>
<h1 id="prism">Prism</h1>
<p>Prism은 광학의 프리즘이 빛을 여러 갈래로 나누듯,
Enum식 타입에 경우 나누기로 패턴매칭을 해주는 접근자입니다.</p>
<p>일정한 케이스를 집중하여 보여준다고 보시면 됩니다.</p>
<p>(개인적인 생각으로 필터와 더 비슷합니다. 일정한 경우만 뽑아내어 주거든요)</p>
<p>여기서부턴 다음과 같은 예제를 고려해 보겠습니다.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sealed</span> <span class="kw">trait</span> Pet</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Dog</span><span class="op">(</span>bark<span class="op">:</span> Bark<span class="op">,</span> howl<span class="op">:</span> Howl<span class="op">)</span> <span class="kw">extends</span> Pet</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Cat</span><span class="op">(</span>meow<span class="op">:</span> Meow<span class="op">,</span> isStray<span class="op">:</span> Bool<span class="op">)</span> <span class="kw">extends</span> Pet</span></code></pre></div>
<h2 id="표현-3">표현</h2>
<p>기본적인 표현법은 다음과 같습니다.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> PrismS<span class="op">[</span>S<span class="op">,</span> A<span class="op">](</span>matching <span class="op">:</span> S <span class="op">=&gt;</span> Either<span class="op">[</span>S<span class="op">,</span> A<span class="op">],</span> review<span class="op">:</span> A <span class="op">=&gt;</span> S<span class="op">)</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Polymorphic case</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> Prism<span class="op">[</span>S<span class="op">,</span> T<span class="op">,</span> A<span class="op">,</span> B<span class="op">](</span>matching<span class="op">:</span> S <span class="op">=&gt;</span> Either<span class="op">[</span>T<span class="op">,</span> A<span class="op">],</span> review<span class="op">:</span> B <span class="op">=&gt;</span> T<span class="op">)</span></span></code></pre></div>
<p>자세히 보면, Prism은 Iso와 review 메소드를 공유한다는 것을 알 수 있습니다.
비슷하게 Lens와 Iso도 get 메소드를 공유합니다.</p>
<p>한편, <code>matching</code>은 구조체에서 있을 수도 있고, 없을 수도 있는 필드를 가져오는 함수입니다.
필드가 없을 경우, Either를 이용해서 변경되지 않은 구조체 값을 그대로 Left에 감싸 가져옵니다.</p>
<p><code>matching</code>은 패턴 매칭처럼 쓸 수도 있는데, 이건 용법 부분에서 다뤄보겠습니다.</p>
<hr />
<p>Profunctor 표현법</p>
<p>Lens에는 <code>Strong</code> 제약조건이 있듯, Prism에는 <code>Choice</code> 제약조건이 있습니다.</p>
<p><code>Choice</code>는 다음 함수를 구현합니다.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trait</span> <span class="ex">Choice</span><span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Necessary</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rights<span class="op">[</span>A<span class="op">,</span> B<span class="op">,</span> S<span class="op">]:</span> P<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>Either<span class="op">[</span>S<span class="op">,</span> A<span class="op">],</span> Either<span class="op">[</span>S<span class="op">,</span> B<span class="op">]]</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lefts can be expressed in terms of rights</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lefts<span class="op">[</span>A<span class="op">,</span> B<span class="op">,</span> S<span class="op">]:</span> P<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>Either<span class="op">[</span>A<span class="op">,</span> S<span class="op">],</span> Either<span class="op">[</span>B<span class="op">,</span> S<span class="op">]]</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>즉, A를 받고 B를 주는 연산이 있을 때, S나 A를 주고 S나 B를 받는 연산으로 승격시킬 수 있습니다.
S를 받게 된다면 특별한 작업 없이 그대로 통과시키게 되겠지요.</p>
<p>이를 이용하여 특정 케이스에 대해서만 작업을 진행할 수 있습니다. 마치 <code>Option</code>의 <code>map</code>/<code>flatMap</code>처럼요.</p>
<p>Prism 자체의 타입은 이렇게 생겼습니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Some pet is a cat - not polymorphic</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OpticS[P, Pet, Cat] = P[Cat, Cat] =&gt; P[Pet, Pet]</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prismPetCat<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> <span class="ex">Choice</span><span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Pet<span class="op">,</span> Cat<span class="op">]</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Option content - polymorphic</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Optic[P, Option[A], Option[B], A, B] = P[A, B] =&gt; P[Option[A], Option[B]]</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prismSome<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> <span class="ex">Choice</span><span class="op">,</span> A<span class="op">,</span> B<span class="op">]</span> <span class="op">:</span> Optic<span class="op">[</span>P<span class="op">,</span> <span class="ex">Option</span><span class="op">[</span>A<span class="op">],</span> <span class="ex">Option</span><span class="op">[</span>B<span class="op">],</span> A<span class="op">,</span> B<span class="op">]</span></span></code></pre></div>
<h3 id="표현의-변환-2">표현의 변환</h3>
<p>어떻게 보면, 렌즈와 비슷한 과정을 따르게 됩니다.</p>
<p>Profunctor 형태에서 일반 형태로 가려면 타입 치환을 하면 됩니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> FindCat<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> Either<span class="op">[</span>N<span class="op">,</span> Cat<span class="op">]</span>  <span class="co">// Find Cat from M</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> FromCat<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> Cat <span class="op">=&gt;</span> N             <span class="co">// Generate N from Cat</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prismPCTyp<span class="op">:</span> PrismS<span class="op">[</span>Pet<span class="op">,</span> Cat<span class="op">]</span> <span class="op">=</span> <span class="fu">PrismS</span><span class="op">(</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prismPetCat[FindCat] : (Cat =&gt; Either[Cat, Cat]) =&gt; (Pet =&gt; Either[Pet, Cat])</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    prismPetCat<span class="op">[</span>FindCat<span class="op">]</span> <span class="op">((</span>cat<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">Right</span><span class="op">(</span>cat<span class="op">)),</span> <span class="co">// matching</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prismPetCat[FromCat] : (Cat =&gt; Cat) =&gt; (Cat =&gt; Pet)</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    prismPetCat<span class="op">[</span>FromCat<span class="op">]</span> <span class="op">(</span>identity<span class="op">)</span> <span class="co">// review</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">)</span></span></code></pre></div>
<p>한편, 일반 형태에서 Profunctor 형태로 가려면 <code>rights</code>를 써서 case-by-case 처리를 하게 합니다.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prismPCTyp<span class="op">:</span> PrismS<span class="op">[</span>Pet<span class="op">,</span> Cat<span class="op">]</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prismPetCat<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> <span class="ex">Choice</span><span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Pet<span class="op">,</span> Cat<span class="op">]</span> <span class="op">=</span> catTrans <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// catTrans : P[Cat, Cat]</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> caseByCase<span class="op">:</span> P<span class="op">[</span>Either<span class="op">[</span>Pet<span class="op">,</span> Cat<span class="op">],</span> Either<span class="op">[</span>Pet<span class="op">,</span> Cat<span class="op">]]</span> <span class="op">=</span> <span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span>rights<span class="op">[</span>Cat<span class="op">,</span> Cat<span class="op">,</span> Pet<span class="op">]</span> <span class="op">(</span>catTrans<span class="op">)</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Finds Cat out of Pet</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">findCatE</span> <span class="op">(</span>pet<span class="op">:</span> Pet<span class="op">):</span> Either<span class="op">[</span>Pet<span class="op">,</span> Cat<span class="op">]</span> <span class="op">=</span> prismPCTyp<span class="op">.</span><span class="fu">matching</span> <span class="op">(</span>pet<span class="op">)</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get back Pet from Cat (or from other kinds of Pet)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">reCatE</span> <span class="op">(</span>mayCat<span class="op">:</span> Either<span class="op">[</span>Pet<span class="op">,</span> Cat<span class="op">]):</span> Pet <span class="op">=</span> mayCat <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="fu">Left</span><span class="op">(</span>pet<span class="op">)</span> <span class="op">=&gt;</span> pet</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="fu">Right</span><span class="op">(</span>cat<span class="op">)</span> <span class="op">=&gt;</span> prismPCTyp<span class="op">.</span><span class="fu">review</span> <span class="op">(</span>cat<span class="op">)</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of type P[Pet, Pet]</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    Profunctor<span class="op">[</span>P<span class="op">].</span><span class="fu">dimap</span> <span class="op">(</span>findCatE<span class="op">)</span> <span class="op">(</span>reCatE<span class="op">)</span> <span class="op">(</span>caseByCase<span class="op">)</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// pet -[findCatE]-&gt; mayCat -[caseByCase]-&gt; mayCat' -[reCatE]-&gt; pet'</span></span></code></pre></div>
<h2 id="용법-2">용법</h2>
<p>위에서 서술한 경우를 확장시켜 봅시다.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sealed</span> <span class="kw">trait</span> Pet</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Dog</span><span class="op">(</span>bark<span class="op">:</span> Bark<span class="op">,</span> howl<span class="op">:</span> Howl<span class="op">)</span> <span class="kw">extends</span> Pet</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Cat</span><span class="op">(</span>meow<span class="op">:</span> Meow<span class="op">,</span> isStray<span class="op">:</span> Bool<span class="op">)</span> <span class="kw">extends</span> Pet</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Parrot</span><span class="op">(</span>says<span class="op">:</span> <span class="ex">String</span><span class="op">)</span> <span class="kw">extends</span> Pet</span></code></pre></div>
<p>여기서 <code>Cat</code>의 경우에만 작업을 하고,
나머지의 경우 아무 작업도 하지 않고 지나고자 하는 경우가 있을 것입니다.</p>
<p>바로 이러한 작업을 처리하기 위해 Prism을 사용합니다.</p>
<p>특히, 내부를 드러낼 필요 없이 Prism만 구현해 주면 케이스를 나누어 분석하고, 변경해 줄 수도 있습니다.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Arrow<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> N</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prismPetCat<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> <span class="ex">Choice</span><span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Pet<span class="op">,</span> Cat<span class="op">]</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Can use lens, but.. let that sink</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> adoptCat<span class="op">:</span> Arrow<span class="op">[</span>Cat<span class="op">,</span> Cat<span class="op">]</span> <span class="op">=</span> cat <span class="op">=&gt;</span> cat<span class="op">.</span><span class="fu">copy</span><span class="op">(</span> isStray <span class="op">=</span> False <span class="op">)</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Apparently, only adopts a cat</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> adoptPet<span class="op">:</span> Arrow<span class="op">[</span>Pet<span class="op">,</span> Pet<span class="op">]</span> <span class="op">=</span> prismPetCat<span class="op">[</span>Arrow<span class="op">]</span> <span class="op">(</span>adoptCat<span class="op">)</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">adoptPet</span> <span class="op">(</span><span class="fu">Dog</span> <span class="op">(</span>bark<span class="op">,</span> howl<span class="op">))</span> <span class="op">==</span> <span class="fu">Dog</span> <span class="op">(</span>bark<span class="op">,</span> howl<span class="op">)</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">adoptPet</span> <span class="op">(</span><span class="fu">Cat</span> <span class="op">(</span>meow<span class="op">,</span> True<span class="op">))</span> <span class="op">==</span> <span class="fu">Cat</span> <span class="op">(</span>meow<span class="op">,</span> False<span class="op">)</span></span></code></pre></div>
<p>여기에 필요하다면, Effect를 섞어줄 수도 있습니다.</p>
<p>허나, 이보다는 앞으로 설명할 (Affine) Traversal로써 더 많이 쓰이는듯 합니다.</p>
<hr />
<h1 id="affine-traversal">Affine Traversal</h1>
<p>Affine Traversal은 구조체에 있을 수도 있고 없을 수도 있는 필드를 표현하는데 씁니다.</p>
<p>위의 <code>Pet</code> 예제를 그대로 써 봅시다.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sealed</span> <span class="kw">trait</span> Pet</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Dog</span><span class="op">(</span>bark<span class="op">:</span> Bark<span class="op">,</span> howl<span class="op">:</span> Howl<span class="op">)</span> <span class="kw">extends</span> Pet</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">Cat</span><span class="op">(</span>meow<span class="op">:</span> Meow<span class="op">,</span> isStray<span class="op">:</span> Bool<span class="op">)</span> <span class="kw">extends</span> Pet</span></code></pre></div>
<p>이 때 고양이의 울음소리 <code>meow</code> 필드만 변경하려면 어떻게 할까요?</p>
<p>Prism으로는 불가능합니다. <code>Meow</code>는 부분에 불과해서, 이로부터 <code>Pet</code>을 만들어 낼 수가 없거든요.</p>
<p>이러한 경우에 적용되는 것이 Affine Traversal입니다.</p>
<h2 id="표현-4">표현</h2>
<p>기본적인 표현법은 역시 위 접근자들과 유사합니다.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> AffTraversalS<span class="op">[</span>S<span class="op">,</span> A<span class="op">](</span>matching <span class="op">:</span> S <span class="op">=&gt;</span> Either<span class="op">[</span>S<span class="op">,</span> A<span class="op">],</span> set<span class="op">:</span> A <span class="op">=&gt;</span> S <span class="op">=&gt;</span> S<span class="op">)</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Polymorphic case</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> AffTraversal<span class="op">[</span>S<span class="op">,</span> T<span class="op">,</span> A<span class="op">,</span> B<span class="op">](</span>matching<span class="op">:</span> S <span class="op">=&gt;</span> Either<span class="op">[</span>T<span class="op">,</span> A<span class="op">],</span> set<span class="op">:</span> B <span class="op">=&gt;</span> S <span class="op">=&gt;</span> T<span class="op">)</span></span></code></pre></div>
<p>각각 Prism과 Lens에서 이미 보았던 <code>matching</code>과 <code>set</code>을 사용함을 알 수 있습니다.</p>
<hr />
<p>Profunctor 표현법</p>
<p>Lens에는 <code>Strong</code>, Prism에는 <code>Choice</code> 제약조건이 있다면, AffineTraversal에는 둘 다 있습니다.</p>
<p>그래서 해당 작업 <code>P</code>는 record와 case-by-case 둘 다 가능한 profunctor가 됩니다.
(정확히는, 제약조건에 의해 둘 다 가능해야 합니다)</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Some pet can meow - not polymorphic</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OpticS[P, Pet, Meow] = P[Meow, Meow] =&gt; P[Pet, Pet]</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTPetMeow<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Pet<span class="op">,</span> Meow<span class="op">]</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Option content - polymorphic</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Optic[P, Option[A], Option[B], A, B] = P[A, B] =&gt; P[Option[A], Option[B]]</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTOption<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">,</span> A<span class="op">,</span> B<span class="op">]</span> <span class="op">:</span> Optic<span class="op">[</span>P<span class="op">,</span> <span class="ex">Option</span><span class="op">[</span>A<span class="op">],</span> <span class="ex">Option</span><span class="op">[</span>B<span class="op">],</span> A<span class="op">,</span> B<span class="op">]</span></span></code></pre></div>
<h3 id="표현의-변환-3">표현의 변환</h3>
<p>Lens와 Prism을 섞어놓은듯 구현이 됩니다.</p>
<p>Profunctor 형태에서 일반 형태로:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> MayMeow<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> Either<span class="op">[</span>N<span class="op">,</span> Meow<span class="op">]</span> <span class="co">// Find Meow from M</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Arrow<span class="op">[</span>M<span class="op">,</span> N<span class="op">]</span> <span class="op">=</span> M <span class="op">=&gt;</span> N                 <span class="co">// Function</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTPMTyp<span class="op">:</span> AffTraversalS<span class="op">[</span>Pet<span class="op">,</span> Meow<span class="op">]</span> <span class="op">=</span> <span class="fu">AffTraversalS</span><span class="op">(</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// affTPetMeow[MayMeow] : (Meow =&gt; Either[Meow, Meow]) =&gt; (Pet =&gt; Either[Pet, Meow])</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    affTPetMeow<span class="op">[</span>MayMeow<span class="op">]</span> <span class="op">((</span>meow<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">Right</span><span class="op">(</span>meow<span class="op">)),</span> <span class="co">// matching</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// affTPetMeow[Arrow] : (Meow =&gt; Meow) =&gt; (Pet =&gt; Pet)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>meow<span class="op">:</span> Meow<span class="op">)</span> <span class="op">=&gt;</span> affTPetMeow<span class="op">[</span>FromMeow<span class="op">]</span> <span class="op">(</span>_ <span class="op">=&gt;</span> meow<span class="op">)</span> <span class="co">// set</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">)</span></span></code></pre></div>
<p>일반 형태에서 Profunctor 형태로:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTPMTyp<span class="op">:</span> AffTraversalS<span class="op">[</span>Pet<span class="op">,</span> Meow<span class="op">]</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTPetMeow<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Pet<span class="op">,</span> Meow<span class="op">]</span> <span class="op">=</span> meowTrans <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// meowTrans : P[Meow, Meow]</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> withOriginal<span class="op">:</span> P<span class="op">[(</span>Pet<span class="op">,</span> Meow<span class="op">),</span> <span class="op">(</span>Pet<span class="op">,</span> Meow<span class="op">)]</span> <span class="op">=</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>      Strong<span class="op">[</span>P<span class="op">].</span>seconds<span class="op">[</span>Meow<span class="op">,</span> Meow<span class="op">,</span> Pet<span class="op">]</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> caseByCase<span class="op">:</span> P<span class="op">[</span>Either<span class="op">[</span>Pet<span class="op">,</span> <span class="op">(</span>Pet<span class="op">,</span> Meow<span class="op">)],</span> Either<span class="op">[</span>Pet<span class="op">,</span> <span class="op">(</span>Pet<span class="op">,</span> Meow<span class="op">)]]</span> <span class="op">=</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>      <span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span>rights<span class="op">[</span>Meow<span class="op">,</span> Meow<span class="op">,</span> Pet<span class="op">]</span> <span class="op">(</span>withOriginal<span class="op">)</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">pullMeow</span> <span class="op">(</span>pet<span class="op">:</span> Pet<span class="op">):</span> Either<span class="op">[</span>Pet<span class="op">,</span> <span class="op">(</span>Pet<span class="op">,</span> Meow<span class="op">)]</span> <span class="op">=</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>      affTPMTyp<span class="op">.</span><span class="fu">matching</span> <span class="op">(</span>pet<span class="op">).</span><span class="fu">map</span> <span class="op">((</span>pet<span class="op">,</span> _<span class="op">))</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">putMeow</span> <span class="op">(</span>beep<span class="op">:</span> Either<span class="op">[</span>Pet<span class="op">,</span> <span class="op">(</span>Pet<span class="op">,</span> Meow<span class="op">)]):</span> Pet <span class="op">=</span> beep <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="fu">Left</span><span class="op">(</span>pet<span class="op">)</span> <span class="op">=&gt;</span> pet</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="fu">Right</span><span class="op">((</span>old<span class="op">,</span> meow<span class="op">))</span> <span class="op">=&gt;</span> affTPMTyp<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>meow<span class="op">)</span> <span class="op">(</span>old<span class="op">)</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    Profunctor<span class="op">[</span>P<span class="op">].</span><span class="fu">dimap</span> <span class="op">(</span>pullMeowE<span class="op">)</span> <span class="op">(</span>putMeowE<span class="op">)</span> <span class="op">(</span>caseByCase<span class="op">)</span></span></code></pre></div>
<p>실눈을 뜨고 보시면, Prism과 Lens를 합성해서 얻었다는 것을 발견하실 수도 있습니다.</p>
<p>어쩌면 Prism과 Lens를 합성해서 얻는 것이 더 쉬울 수도 있겠네요.</p>
<p>Pet -&gt; Cat으로 가는 Prism과, Cat -&gt; Meow 로 가는 Lens를 만든 후 합성하면 Affine Traversal이 되니까요.</p>
<h2 id="용법-3">용법</h2>
<p>이렇게 있을 수도 있고, 없을 수도 있는 필드들은 Algebraic data type에서 자주 보입니다.</p>
<p>특히 ADT를 nesting할 경우, 접근, 특히 수정을 보다 간편히 하기 위해 쓸 수 있습니다.</p>
<p>위의 Prism에서 봤던 예제는 하나의 필드, <code>isStray</code>만을 수정했었죠? 이렇게도 구현이 가능합니다.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTPetStray<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> Pet<span class="op">,</span> Bool<span class="op">]</span> <span class="op">=</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    prismPetCat compose lensCatStray</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> affTPMTyp<span class="op">:</span> AffTraversalS<span class="op">[</span>Pet<span class="op">,</span> Bool<span class="op">]</span> <span class="op">=</span> <span class="op">???</span> <span class="co">// omitted</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Only adopts cat (...) by setting isStray to false</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> adoptPet<span class="op">:</span> Cat <span class="op">=&gt;</span> Cat <span class="op">=</span> affTPMTyp<span class="op">.</span><span class="fu">set</span> <span class="op">(</span>False<span class="op">)</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">adoptPet</span> <span class="op">(</span><span class="fu">Dog</span> <span class="op">(</span>bark<span class="op">,</span> howl<span class="op">))</span> <span class="op">==</span> <span class="fu">Dog</span> <span class="op">(</span>bark<span class="op">,</span> howl<span class="op">)</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">adoptPet</span> <span class="op">(</span><span class="fu">Cat</span> <span class="op">(</span>meow<span class="op">,</span> True<span class="op">))</span> <span class="op">==</span> <span class="fu">Cat</span> <span class="op">(</span>meow<span class="op">,</span> False<span class="op">)</span></span></code></pre></div>
<p>한편, <code>Traversal</code>로써의 쓰임새도 상당히 중요합니다.
그러면 이제 Traversal이 무엇인지 다뤄보겠습니다.</p>
<hr />
<h1 id="traversal">Traversal</h1>
<p>Traversal은 구조체에 대상이 여럿 있는 경우에 사용하는 접근자입니다.</p>
<p>예를 들어, <code>List[Foo]</code>, <code>Array[Foo]</code>, <code>Map[K, Foo]</code>, <code>BinaryTree[Foo]</code> 등에는
<code>Foo</code>라는 대상이 여럿 있죠.</p>
<p>Traversal은 이러한 데이터구조를 순회하면서 작업한다고 보시면 됩니다.</p>
<p>다음과 같은 <code>BinTree</code>를 예로 삼아 표현을 접근해 봅시다.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="ex">Label</span> <span class="op">=</span> <span class="ex">String</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sealed</span> <span class="kw">trait</span> BinTree</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">object</span> BinEmpty <span class="kw">extends</span> BinTree</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">BinBranch</span><span class="op">(</span>brl<span class="op">:</span> BinTree<span class="op">,</span> brr<span class="op">:</span> BinTree<span class="op">,</span> label<span class="op">:</span> <span class="ex">Label</span><span class="op">)</span> <span class="kw">extends</span> BinTree</span></code></pre></div>
<h2 id="표현-5">표현</h2>
<p>위에서 설명한 접근자들과는 다르게, 안타깝게도 Traversal를 쉽게 표현할 수 있는 방법은 없습니다.</p>
<p>대신 그보다 살짝 복잡하지만 Profunctor 방식보단 간단한 방식이 있습니다.</p>
<p>Traversal의 경우, 결과를 모으는 구도가 되므로 Monoid와 관계가 깊습니다.
그래서 다음과 같이 <code>Monoidal</code> 제약조건이 등장합니다.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trait</span> Monoidal<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> empty<span class="op">:</span> P<span class="op">[</span><span class="bu">Unit</span><span class="op">,</span> <span class="bu">Unit</span><span class="op">]</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> both<span class="op">[</span>A<span class="op">,</span> B<span class="op">,</span> S<span class="op">,</span> T<span class="op">]:</span> P<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[</span>S<span class="op">,</span> T<span class="op">]</span> <span class="op">=&gt;</span> P<span class="op">[(</span>A<span class="op">,</span> S<span class="op">),</span> <span class="op">(</span>B<span class="op">,</span> T<span class="op">)]</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>빈 변환이 주어지고, 두 변환을 양 옆으로 합칠 수도 있군요.</p>
<p>Profunctor 표현법은 다음과 같이 나옵니다. 지금까지 중에서 제약조건이 가장 강합니다.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// OpticS[P, BinTree, Label] = P[String, Label] =&gt; P[BinTree, BinTree]</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> travTreeLabel<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">,</span> Monoidal<span class="op">]</span> <span class="op">:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinTree<span class="op">,</span> <span class="ex">Label</span><span class="op">]</span></span></code></pre></div>
<p>이보다 다루기 편한 방법으로, <code>Applicative</code>를 사용해서 표현할 수도 있습니다.</p>
<p>합성은 똑같이 쉽습니다만, 다른 접근자들이 Profunctor를 쓰기에 호환성이 떨어지게 됩니다.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> TraversalS<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Applicative<span class="op">,</span> S<span class="op">,</span> A<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>A <span class="op">=&gt;</span> F<span class="op">[</span>A<span class="op">])</span> <span class="op">=&gt;</span> <span class="op">(</span>S <span class="op">=&gt;</span> F<span class="op">[</span>S<span class="op">])</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Traversal<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Applicative<span class="op">,</span> S<span class="op">,</span> T<span class="op">,</span> A<span class="op">,</span> B<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>A <span class="op">=&gt;</span> F<span class="op">[</span>B<span class="op">])</span> <span class="op">=&gt;</span> <span class="op">(</span>S <span class="op">=&gt;</span> F<span class="op">[</span>T<span class="op">])</span></span></code></pre></div>
<p>사실상 모든 Effect는 <code>Applicative</code>라고 보면 되므로,
어떤 Effect이든 Traversal을 이용하면 필드로부터 상위 구조체로 승격시킬 수 있습니다.</p>
<p><code>F</code>라는 <code>Applicative</code> Effect가 있을 때,
다음 타입은 Profunctor, Strong, Choice, Monoidal 조건을 모두 만족합니다.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Given applicative F[_]</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ProF<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=</span> A <span class="op">=&gt;</span> F<span class="op">[</span>B<span class="op">]</span></span></code></pre></div>
<p>따라서, 대입을 해 보면 자동으로 Profunctor 형태를 Applicative 형태로 바꿔줄 수 있습니다.</p>
<p>(예를 들어 <code>travTreeLabel[ProF]</code>도 Profunctor가 됩니다)</p>
<p>반대로 Applicative 표현에서 Profunctor 표현을 얻는 것은 어렵습니다.</p>
<p>그런 만큼, 만약 구현을 한다면 Profunctor 위주로 구현을 한 뒤
필요할 때 Applicative 형태로 쓰는 것이 좋지 않을까 싶습니다.</p>
<p>쉬운 표현법이 없으니, 위에서 예로 든 <code>BinTree</code>의 Traversal은 어떻게 만들어야 할까요?</p>
<p>다음과 같이 하면 됩니다.</p>
<ol type="1">
<li>In-order Traversal</li>
</ol>
<div class="sourceCode" id="cb50"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="ex">Label</span> <span class="op">=</span> <span class="ex">String</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// 케이스는 Choice의 lefts/rights를 이용합니다.</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sealed</span> <span class="kw">trait</span> BinTree</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">object</span> BinEmpty <span class="kw">extends</span> BinTree</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// BinBranch는 brl에 대해 적용하고, brr에 대해 적용한 후, label까지 변환을 적용하고,</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// 이를 Monoidal의 both를 이용해 하나로 만들어 줍니다.</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="kw">class</span> <span class="fu">BinBranch</span><span class="op">(</span>brl<span class="op">:</span> BinTree<span class="op">,</span> brr<span class="op">:</span> BinTree<span class="op">,</span> label<span class="op">:</span> <span class="ex">Label</span><span class="op">)</span> <span class="kw">extends</span> BinTree</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// 동등한 타입: BinTree &lt;-&gt; Either[BinEmpty, BinBranch]</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> isoCase<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinTree<span class="op">,</span> Either<span class="op">[</span>BinEmpty<span class="op">,</span> BinBranch<span class="op">]]</span> <span class="op">=</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    Profunctor<span class="op">[</span>P<span class="op">].</span>dimap</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span> <span class="cf">case</span> e@BinEmpty <span class="op">=&gt;</span> <span class="fu">Left</span> <span class="op">(</span>e<span class="op">);</span> <span class="cf">case</span> b@<span class="op">(</span><span class="fu">BinBranch</span><span class="op">(</span>_<span class="op">,</span> _<span class="op">,</span> _<span class="op">))</span> <span class="op">=&gt;</span> <span class="fu">Right</span> <span class="op">(</span>b<span class="op">)</span> <span class="op">}</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span> <span class="cf">case</span> <span class="fu">Left</span><span class="op">(</span>e<span class="op">)</span> <span class="op">=&gt;</span> e<span class="op">;</span> <span class="cf">case</span> <span class="fu">Right</span><span class="op">(</span>b<span class="op">)</span> <span class="op">=&gt;</span> b <span class="op">}</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// In-order Traversal</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> travInorder<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">,</span> Monoidal<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinTree<span class="op">,</span> <span class="ex">Label</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>modLabel<span class="op">:</span> P<span class="op">[</span><span class="ex">Label</span><span class="op">,</span> <span class="ex">Label</span><span class="op">])</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">// In-order 순서의 접근. BinTree를 변환하기 위해서 travInorder를 재귀적으로 사용합니다.</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> modInorder<span class="op">:</span> P<span class="op">[(</span>BinTree<span class="op">,</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> BinTree<span class="op">)),</span> <span class="op">(</span>BinTree<span class="op">,</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> BinTree<span class="op">))]</span> <span class="op">=</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">(</span>travInorder<span class="op">)</span> <span class="op">(</span>Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">(</span>modLabel<span class="op">)</span> <span class="op">(</span>travInorder<span class="op">))</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>      <span class="co">// 동등한 타입: BinBranch &lt;-&gt; (BinTree, (Label, BinTree))</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> isoBranch<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinBranch<span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> BinTree<span class="op">))]</span> <span class="op">=</span></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>        Profunctor<span class="op">[</span>P<span class="op">].</span>dimap</span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="fu">BinBranch</span><span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span>brl<span class="op">,</span> <span class="op">(</span>label<span class="op">,</span> brr<span class="op">))</span> <span class="op">}</span></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="op">(</span>brl<span class="op">,</span> <span class="op">(</span>label<span class="op">,</span> brr<span class="op">))</span> <span class="op">=&gt;</span> <span class="fu">BinBranch</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">}</span></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>      <span class="co">// BinBranch의 변환, Tuple을 다시 Record로 만들어줍니다.</span></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> modBranch<span class="op">:</span> P<span class="op">[</span>BinBranch<span class="op">,</span> BinBranch<span class="op">]</span> <span class="op">=</span> <span class="fu">isoBranch</span> <span class="op">(</span>modInorder<span class="op">)</span></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Either[BinEmpty, BinBranch]</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> caseSum<span class="op">:</span> P<span class="op">[</span>Either<span class="op">[</span>BinEmpty<span class="op">,</span> BinBranch<span class="op">],</span> Either<span class="op">[</span>BinEmpty<span class="op">,</span> BinBranch<span class="op">]]</span> <span class="op">=</span></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span><span class="fu">rights</span> <span class="op">(</span>modBranch<span class="op">)</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>      <span class="fu">isoCase</span> <span class="op">(</span>caseSum<span class="op">)</span> <span class="co">// P[BinTree, BinTree]</span></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Pre-order, Post-order Traversal</li>
</ol>
<div class="sourceCode" id="cb51"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> travPreorder<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">,</span> Monoidal<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinTree<span class="op">,</span> <span class="ex">Label</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>modLabel<span class="op">:</span> P<span class="op">[</span><span class="ex">Label</span><span class="op">,</span> <span class="ex">Label</span><span class="op">])</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Pre-order 순서의 접근: label -&gt; brl -&gt; brr</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> modPreorder<span class="op">:</span> P<span class="op">[(</span><span class="ex">Label</span><span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> BinTree<span class="op">)),</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> BinTree<span class="op">))]</span> <span class="op">=</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">(</span>modLabel<span class="op">)</span> <span class="op">(</span>Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">(</span>travPreorder<span class="op">)</span> <span class="op">(</span>travPreorder<span class="op">))</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> isoBranch<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinBranch<span class="op">,</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> BinTree<span class="op">))]</span> <span class="op">=</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        Profunctor<span class="op">[</span>P<span class="op">].</span>dimap</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="fu">BinBranch</span><span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span>label<span class="op">,</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">))</span> <span class="op">}</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="op">(</span>label<span class="op">,</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">))</span> <span class="op">=&gt;</span> <span class="fu">BinBranch</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">}</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">isoCase</span> <span class="op">(</span><span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span><span class="fu">rights</span> <span class="op">(</span><span class="fu">isoBranch</span> <span class="op">(</span>modPreorder<span class="op">)))</span> <span class="co">// P[BinTree, BinTree]</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> travPostorder<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">,</span> Monoidal<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinTree<span class="op">,</span> <span class="ex">Label</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>modLabel<span class="op">:</span> P<span class="op">[</span><span class="ex">Label</span><span class="op">,</span> <span class="ex">Label</span><span class="op">])</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Post-order 순서의 접근: brl -&gt; brr -&gt; label</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> modPostorder<span class="op">:</span> P<span class="op">[((</span>BinTree<span class="op">,</span> BinTree<span class="op">),</span> <span class="ex">Label</span><span class="op">),</span> <span class="op">((</span>BinTree<span class="op">,</span> BinTree<span class="op">),</span> <span class="ex">Label</span><span class="op">)]</span> <span class="op">=</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>        Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">((</span>Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">(</span>travPostorder<span class="op">)</span> <span class="op">(</span>travPostorder<span class="op">))</span> <span class="op">(</span>modLabel<span class="op">)</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> isoBranch<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinBranch<span class="op">,</span> <span class="op">((</span>BinTree<span class="op">,</span> BinTree<span class="op">),</span> <span class="ex">Label</span><span class="op">)]</span> <span class="op">=</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>        Profunctor<span class="op">[</span>P<span class="op">].</span>dimap</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="fu">BinBranch</span><span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">((</span>brl<span class="op">,</span> brr<span class="op">),</span> label<span class="op">)</span> <span class="op">}</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="op">((</span>brl<span class="op">,</span> brr<span class="op">),</span> label<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">BinBranch</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">}</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>      <span class="fu">isoCase</span> <span class="op">(</span><span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span><span class="fu">rights</span> <span class="op">(</span><span class="fu">isoBranch</span> <span class="op">(</span>modPostorder<span class="op">)))</span> <span class="co">// P[BinTree, BinTree]</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li>Left-side only Traversal</li>
</ol>
<div class="sourceCode" id="cb52"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> travLeft<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Strong<span class="op">,</span> <span class="ex">Choice</span><span class="op">,</span> Monoidal<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinTree<span class="op">,</span> <span class="ex">Label</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>modLabel<span class="op">:</span> P<span class="op">[</span><span class="ex">Label</span><span class="op">,</span> <span class="ex">Label</span><span class="op">])</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">// label -&gt; brl 순서로 접근, brr은 firsts를 써서 pass</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> modLeftside<span class="op">:</span> P<span class="op">[(</span><span class="ex">Label</span><span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> BinTree<span class="op">)),</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> BinTree<span class="op">))]</span> <span class="op">=</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        Monoidal<span class="op">[</span>P<span class="op">].</span><span class="fu">both</span> <span class="op">(</span>modLabel<span class="op">)</span> <span class="op">(</span><span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span><span class="fu">firsts</span> <span class="op">(</span>travLeft<span class="op">))</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> isoBranch<span class="op">[</span>P<span class="op">[</span>_<span class="op">,</span> _<span class="op">]:</span> Profunctor<span class="op">]:</span> OpticS<span class="op">[</span>P<span class="op">,</span> BinBranch<span class="op">,</span> <span class="op">(</span><span class="ex">Label</span><span class="op">,</span> <span class="op">(</span>BinTree<span class="op">,</span> BinTree<span class="op">))]</span> <span class="op">=</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>        Profunctor<span class="op">[</span>P<span class="op">].</span>dimap</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="fu">BinBranch</span><span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span>label<span class="op">,</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">))</span> <span class="op">}</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">{</span> <span class="cf">case</span> <span class="op">(</span>label<span class="op">,</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">))</span> <span class="op">=&gt;</span> <span class="fu">BinBranch</span> <span class="op">(</span>brl<span class="op">,</span> brr<span class="op">,</span> label<span class="op">)</span> <span class="op">}</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">isoCase</span> <span class="op">(</span><span class="ex">Choice</span><span class="op">[</span>P<span class="op">].</span><span class="fu">rights</span> <span class="op">(</span><span class="fu">isoBranch</span> <span class="op">(</span>modPreorder<span class="op">)))</span> <span class="co">// P[BinTree, BinTree]</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>이런 방식으로, 원하는 순서로 원하는 원소에만 접근하는 Traversal들을 만들 수 있습니다.</p>
<p>이 방식은 Profunctor를 그대로 이용하기에 조금 복잡하지만,
일반적인 Optics 라이브러리에선 이보다 더 쉽게 만드는 방법이 있습니다.</p>
<p>매크로를 이용하여 자동으로 Traversal, Lens, Prism 등을 생성하는 경우도 많습니다.
(다만 이것을 구현하려면 매크로를 따져봐야겠죠)</p>
<h2 id="용법-4">용법</h2>
<p>위에서 짤막히 언급했듯이, 구조체의 일정 부분들에 대한 Effect 실행이 필요할 때 쓰입니다.</p>
<p>특히 Traversal의 경우 데이터 구조로부터 연산의 합성 순서를 정할 수가 있습니다.</p>
<p>그렇다고 주어진 Traversal에 제약을 받는 것은 아닙니다.
<code>Applicative</code> Effect는 주어진 순서를 무시할 수 있거든요.</p>
<p>왜 Applicative가 나오냐구요?
위에서 보았듯, Profunctor 표현으로부터 다음과 같은 Applicative 표현을 얻을 수 있기 때문입니다.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Assume in-order traversal</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> travTLApp<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Applicative<span class="op">]:</span> <span class="op">(</span><span class="ex">Label</span> <span class="op">=&gt;</span> F<span class="op">[</span><span class="ex">Label</span><span class="op">])</span> <span class="op">=&gt;</span> <span class="op">(</span>BinTree <span class="op">=&gt;</span> F<span class="op">[</span>BinTree<span class="op">])</span></span></code></pre></div>
<p>구체적으로, Traversal은 다음과 같이 사용이 가능합니다.</p>
<ol type="1">
<li><strong>합 구하기</strong></li>
</ol>
<p>다음 타입 생성자를 생각해 봅시다.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ConstL<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="ex">Label</span></span></code></pre></div>
<p>상당히 단순해 보이는 이 타입도 <code>Functor</code>의 조건을 만족합니다.</p>
<p>허나 더 중요한 사실은,
<code>Label</code>이 합칠 수 있는 <code>Monoid</code>라면 <code>ConstL</code>은 <code>Applicative</code>가 된다는 것입니다.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trait</span> Applicative<span class="op">[</span>F<span class="op">[</span>_<span class="op">]:</span> Functor<span class="op">]</span> <span class="op">{</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> pure<span class="op">[</span>A<span class="op">]:</span> A <span class="op">=&gt;</span> F<span class="op">[</span>A<span class="op">]</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ap<span class="op">[</span>A<span class="op">,</span> B<span class="op">]:</span> F<span class="op">[</span>A <span class="op">=&gt;</span> B<span class="op">]</span> <span class="op">=&gt;</span> F<span class="op">[</span>A<span class="op">]</span> <span class="op">=&gt;</span> F<span class="op">[</span>B<span class="op">]</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">implicit</span> <span class="kw">val</span> applConstL<span class="op">:</span> Applicative<span class="op">[</span>ConstL<span class="op">]</span> <span class="op">=</span> <span class="kw">new</span> Applicative<span class="op">[</span>ConstL<span class="op">]</span> <span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> pure<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> _ <span class="op">=&gt;</span> Monoid<span class="op">[</span><span class="ex">Label</span><span class="op">].</span>mempty</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ap<span class="op">[</span>A<span class="op">,</span> B<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>ff<span class="op">)</span> <span class="op">=&gt;</span> <span class="op">(</span>fx<span class="op">)</span> <span class="op">=&gt;</span> Monoid<span class="op">[</span><span class="ex">Label</span><span class="op">].</span><span class="fu">mappend</span> <span class="op">(</span>ff<span class="op">)</span> <span class="op">(</span>fx<span class="op">)</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>여기서의 <code>ap</code>는 결과값을 무시하고 <code>Label</code>만 합해줍니다.</p>
<p>이 Applicative를 <code>Traversal</code>에 적용하면 어떻게 될까요?</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">extractLabel</span> <span class="op">(</span>label<span class="op">:</span> <span class="ex">Label</span><span class="op">):</span> ConstL<span class="op">[</span><span class="ex">Label</span><span class="op">]</span> <span class="op">=</span> label</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">addAllLabel</span> <span class="op">(</span>tree<span class="op">:</span> BinTree<span class="op">):</span> <span class="ex">Label</span> <span class="op">=</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    travTLApp<span class="op">[</span>ConstL<span class="op">]</span> <span class="op">(</span>extractLabel<span class="op">)</span> <span class="op">(</span>tree<span class="op">)</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// addAllLabel (BinBranch (BinEmpty, BinBranch (BinEmpty, BinEmpty, &quot;bar&quot;), &quot;foo&quot;)) == &quot;barfoo&quot;</span></span></code></pre></div>
<p>위와 같이 <code>extractLabel</code>을 넣어주면,
<code>tree</code>의 Label들을 순회 순서대로 합한 문자열을 돌려줍니다!</p>
<p>Label의 개수를 가져오고 싶다면 어떻게 해야 할까요?</p>
<p><code>Sum</code>이라는 타입이 있어 더하기에 기반한 <code>Monoid</code>를 준다고 가정하면,</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ConstSum<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> Sum<span class="op">[</span><span class="bu">Int</span><span class="op">]</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">singleSum</span> <span class="op">(</span>label<span class="op">:</span> <span class="ex">Label</span><span class="op">):</span> ConstSum<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="fu">Sum</span><span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">numLabels</span> <span class="op">(</span>tree<span class="op">:</span> BinTree<span class="op">):</span> Sum<span class="op">[</span><span class="bu">Int</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    travTLApp<span class="op">[</span>ConstSum<span class="op">]</span> <span class="op">(</span>singleSum<span class="op">)</span> <span class="op">(</span>tree<span class="op">)</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// numLabels (BinBranch (BinEmpty, BinBranch (BinEmpty, BinEmpty, &quot;bar&quot;), &quot;foo&quot;)) == Sum(2)</span></span></code></pre></div>
<p>당연히 라벨들의 목록 <code>List[Label]</code>를 가져오고 싶은 경우도 있겠죠?</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> ConstLList<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="ex">List</span><span class="op">[</span><span class="ex">Label</span><span class="op">]</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">intoList</span> <span class="op">(</span>label<span class="op">:</span> <span class="ex">Label</span><span class="op">):</span> ConstLList<span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="ex">List</span><span class="op">(</span>label<span class="op">)</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">labelsToList</span> <span class="op">(</span>tree<span class="op">:</span> BinTree<span class="op">):</span> <span class="ex">Label</span> <span class="op">=</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    travTLApp<span class="op">[</span>ConstLList<span class="op">]</span> <span class="op">(</span>intoList<span class="op">)</span> <span class="op">(</span>tree<span class="op">)</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// labelsToList (BinBranch (BinEmpty, BinBranch (BinEmpty, BinEmpty, &quot;bar&quot;), &quot;foo&quot;)) == List(&quot;bar&quot;, &quot;foo&quot;)</span></span></code></pre></div>
<p>이런 방식으로 <code>Traversal</code>을 이용하면 데이터구조의 요약이 가능합니다.</p>
<ol start="2" type="1">
<li><strong>가능성 나열하기</strong></li>
</ol>
<p>List 모나드를 아신다면,
이것으로 가능성을 나열할 수도 있다는 것을 잘 아실 겁니다.</p>
<p>여기에 Traversal을 사용하면 자료구조를 순회하면서 가능성을 나열할 수 있습니다.</p>
<p>예를 들어, 각각의 <code>Label</code>에 대해 다음과 같이 가지치기를 한다고 생각해 봅시다.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">procLabel</span> <span class="op">(</span>label<span class="op">:</span> <span class="ex">Label</span><span class="op">):</span> <span class="ex">List</span><span class="op">[</span><span class="ex">Label</span><span class="op">]</span> <span class="op">=</span> label <span class="cf">match</span> <span class="op">{</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="ss">s&quot;&quot;</span> <span class="op">=&gt;</span> <span class="ex">List</span><span class="op">()</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="ss">s&quot;$foo</span><span class="st">|</span><span class="ss">$bar&quot;</span> <span class="op">=&gt;</span> <span class="ex">List</span><span class="op">(</span>foo<span class="op">,</span> bar<span class="op">)</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> l <span class="op">=&gt;</span> <span class="ex">List</span><span class="op">(</span>l<span class="op">)</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>이것을 <code>Traversal</code>에 넣어주면 어떻게 될까요?</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">possible</span> <span class="op">(</span>tree<span class="op">:</span> BinTree<span class="op">):</span> <span class="ex">List</span><span class="op">[</span><span class="ex">Label</span><span class="op">]</span> <span class="op">=</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    travTLApp<span class="op">[</span><span class="ex">List</span><span class="op">]</span> <span class="op">(</span>procLabel<span class="op">)</span> <span class="op">(</span>tree<span class="op">)</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> tree<span class="op">:</span> BinTree <span class="op">=</span> <span class="fu">BinBranch</span> <span class="op">(</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">BinBranch</span> <span class="op">(</span>BinEmpty<span class="op">,</span> BinEmpty<span class="op">,</span> <span class="st">&quot;left1|left2&quot;</span><span class="op">),</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">BinBranch</span> <span class="op">(</span>BinEmpty<span class="op">,</span> BinEmpty<span class="op">,</span> <span class="st">&quot;right1|right2&quot;</span><span class="op">),</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;mid&quot;</span><span class="op">)</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">/*</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="co">  possible (tree) == [</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="co">    BinBranch (BinBranch (BinEmpty, BinEmpty, &quot;left1&quot;), BinBranch (BinEmpty, BinEmpty, &quot;right1&quot;), &quot;mid&quot;),</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a><span class="co">    BinBranch (BinBranch (BinEmpty, BinEmpty, &quot;left1&quot;), BinBranch (BinEmpty, BinEmpty, &quot;right2&quot;), &quot;mid&quot;),</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a><span class="co">    BinBranch (BinBranch (BinEmpty, BinEmpty, &quot;left2&quot;), BinBranch (BinEmpty, BinEmpty, &quot;right1&quot;), &quot;mid&quot;),</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a><span class="co">    BinBranch (BinBranch (BinEmpty, BinEmpty, &quot;left2&quot;), BinBranch (BinEmpty, BinEmpty, &quot;right2&quot;), &quot;mid&quot;),</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a><span class="co">  ]</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a><span class="co">  */</span></span></code></pre></div>
<p>즉, 해당 <code>Label</code>을 가능한 <code>Label</code>들로 바꾼 <code>BinTree</code>들의 List를 죽 뽑아내게 됩니다.
일정 형식의 Backtracking을 표현할 수 있는 것이죠.</p>
<p>물론 <code>Label</code>의 경우 상당히 단순한 경우이고,
더 복잡한 경우 보다 효과적으로 적용이 가능합니다.</p>
<p>(TODO 예제: 비동기 처리)</p>
<h1 id="다루지-않은-주제들">다루지 않은 주제들</h1>
<p>다음과 같은 optics 관련 주제들이 있습니다.</p>
<ul>
<li>Getter, Fold, Setter, Review - 좀 더 간단한 접근자들입니다.</li>
<li>Indexed Optics - 인덱스는 특히 다루기가 까다로운 편입니다.</li>
<li>Optics Combinators - Optics를 이용한 여러 연산들입니다.</li>
<li>(분명 더 있는데 지금은 기억이 잘 나지 않네요)</li>
</ul>
<p>기회가 된다면 나중에 소개해 보도록 하겠습니다.</p>
<h2 id="추신">추신</h2>
<p>소개글에 대한 아이디어가 있어 작성했는데, 만족스럽게 나오진 않았습니다.
조만간 다시 정리해서, 제대로 고쳐 작성해보겠습니다.</p>
    </section>
</article>

        </main>

        <footer>
            <nav>
                <a href="../../ko-KR"><i class="fa-solid fa-house"></i></a>
                <a href="../../ko-KR/about.html"><i class="fa-solid fa-circle-question"></i></a>
                <a href="../../ko-KR/contact.html"><i class="fa-solid fa-address-card"></i></a>
                <a href="../../ko-KR/archive.html"><i class="fa-solid fa-box-open"></i></a>
            </nav>
            <div class="hakyll">
                Site generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </div>
        </footer>
    </body>
</html>
